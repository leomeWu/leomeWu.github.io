---
title: epoll
date: 2023-12-22 13:10:00 +0800
categories: [ustc, net-prog]
tags: [net]     # TAG names should always be lowercase
author: wyb
---

## 什么是IO多路复用
在日常生活中，这样的模型其实随处可见，想象这样一个场景：我们在海底捞吃火锅。尽管海底捞以热情的服务著称，但是他也不能做到给每一桌客人都配备一个服务员。服务员在几个桌子之间辗转腾挪，这就是一种多路复用。

回到网络编程的世界中，IO多路复用变成了这样子。

多路：存在多个需要被服务（监听事件）的socket fd

复用：复用一个thread 同时为多个 fd 提供处理服务

## 多路复用的实现
select

## epoll内核源码解读
linux-5.7-rc4/include/linux/eventpoll.h

linux-5.7-rc4/fs/eventpoll.c

linux-5.7-rc4/include/uapi/linux/eventpoll.h
### epoll模块初始化
~~~c
static int __init eventpoll_init(void)
{
...
	/* Allocates slab cache used to allocate "struct epitem" items */
	epi_cache = kmem_cache_create("eventpoll_epi", sizeof(struct epitem),
			0, SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);

	/* Allocates slab cache used to allocate "struct eppoll_entry" */
	pwq_cache = kmem_cache_create("eventpoll_pwq",
		sizeof(struct eppoll_entry), 0, SLAB_PANIC|SLAB_ACCOUNT, NULL);

	return 0;
}
fs_initcall(eventpoll_init);
~~~

epoll模块的初始化函数使用eventpoll_init进行了初始化，这里的fs_initcall是一个用于初始化内核功能模块的宏，作用和我们写内核模块
用到的module_init差不多，本文不对这个宏做讨论，更详细的解释可见[fs_initcall](https://cloud.tencent.com/developer/article/1554770)

在以上初始化过程中，使用了kmem_cache_create提前开辟了epi和pwq的内存池，这在后续的操作中可以节省malloc的时间，提高效率。


### epoll_create
~~~c
SYSCALL_DEFINE1(epoll_create1, int, flags)
{
	return do_epoll_create(flags);
}

SYSCALL_DEFINE1(epoll_create, int, size)
{
	if (size <= 0)
		return -EINVAL;

	return do_epoll_create(0);
}
~~~
以上是在对应于用户空间epoll_create的系统调用，不管是epoll_create还是epoll_create，最后都是调用的do_epoll_create。

~~~c
/*
 * Open an eventpoll file descriptor.
 */
static int do_epoll_create(int flags)
{
	int error, fd;
	struct eventpoll *ep = NULL;
	struct file *file;

	/* Check the EPOLL_* constant for consistency.  */
	BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);

	if (flags & ~EPOLL_CLOEXEC)
		return -EINVAL;
	/*
	 * Create the internal data structure ("struct eventpoll").
	 */
	error = ep_alloc(&ep);
	if (error < 0)
		return error;
	/*
	 * Creates all the items needed to setup an eventpoll file. That is,
	 * a file structure and a free file descriptor.
	 */
	fd = get_unused_fd_flags(O_RDWR | (flags & O_CLOEXEC));
	if (fd < 0) {
		error = fd;
		goto out_free_ep;
	}
	file = anon_inode_getfile("[eventpoll]", &eventpoll_fops, ep,
				 O_RDWR | (flags & O_CLOEXEC));
	if (IS_ERR(file)) {
		error = PTR_ERR(file);
		goto out_free_fd;
	}
	ep->file = file;
	fd_install(fd, file);
	return fd;

out_free_fd:
	put_unused_fd(fd);
out_free_ep:
	ep_free(ep);
	return error;
}
~~~
使用get_unused_fd_flags获取一个未使用文件描述符，anon_inode_getfile分配一个新的文件结构对象（struct file *），将fs与file结构绑定

### epoll_ctl
我们先来看下用户空间的epoll_ctl
~~~c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)

~~~
epfd: epoll 实例的文件描述符，通过 epoll_create 或 epoll_create1 获得。

op: 控制操作，可以是以下三者之一：
- EPOLL_CTL_ADD: 将文件描述符 fd 添加到 epoll 实例中。
- EPOLL_CTL_MOD: 修改文件描述符 fd 在 epoll 实例中的事件关注方式。
- EPOLL_CTL_DEL: 从 epoll 实例中删除文件描述符 fd。

fd: 要进行操作的文件描述符

event: 指向一个 struct epoll_event 结构的指针，定义了关注的事件类型和相关的数据

